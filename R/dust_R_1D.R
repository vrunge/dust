
#' dust_R_1D
#'
#' @description DUST algorithm for univariate time-series (with different possible data models)
#' @param data a vector of data to segment generated by \code{dataGenerator_1D}
#' @param penalty penalty value (non-negative)
#' @param type type of cost to use: \code{"gauss"}, \code{"exp"}, \code{"poisson"}, \code{"geom"}, \code{"bern"}, \code{"binom"}, \code{"negbin"}
#' @param pruningOpt the pruning option to use. 0 = nothing, 1 = PELT, 2 = dust, 3 = PELT + dust
#' @return a list with (1) the change-point elements (each last index of each segment in \code{changepoints}), (2) a vector `\code{nb} saving the number of non-pruned elements at each iteration, (3) a vector \code{lastIndexSet} containing the non-pruned indices at the end of the algo and (4) a vector \code{costQ} saving the optimal cost at each time step.
#' @examples
#' n <- 100
#'
#' type <- "gauss"
#' data <- dataGenerator_1D(chpts = c(n/2,n), parameters = c(0,2), type = type)
#' dust_R_1D(data, 2*log(n), type = type)
#'
#' type <- "poisson"
#' data <- dataGenerator_1D(chpts = c(n/2,n), parameters = c(5,2), type = type)
#' dust_R_1D(data, 2*log(n), type = type)
#'
#' type <- "exp"
#' data <- dataGenerator_1D(chpts = c(n/2,n), parameters = c(5,1), type = type)
#' dust_R_1D(data, 2*log(n), type = type)
#'
#' type <- "binom"
#' data <- dataGenerator_1D(chpts = c(n/2,n), parameters = c(0.01,0.02), type = type)
#' dust_R_1D(data/10, 2*log(n), type = type, pruningOpt = 3)
dust_R_1D <- function(data,
                      penalty = 2*log(length(data)),
                      type = "gauss",
                      pruningOpt = 2)
{
  ## pruningOpt == 0: nothing
  ## pruningOpt == 1: PELT
  ## pruningOpt == 2: dust
  ## pruningOpt == 3: dust + PELT

  ##########  ##########  ##########  ##########  ##########

  if(!is.vector(data)){stop('data is not a vector')}
  if(length(data) <= 1){stop('no data to segment')}
  if(penalty < 0){stop('penalty must be non negative')}

  allowed.types <- c("gauss", "exp", "poisson", "geom", "bern", "binom", "negbin")
  if(!type %in% allowed.types){stop('type must be one of: ', paste(allowed.types, collapse=", "))}

  ##########  ##########  ##########  ##########  ##########
  ###
  ### preprocessing
  ###
  ### S used with the shift operator
  ###
  n <- length(data)
  stat <- statistic(type = type)
  S <- c(0, cumsum(stat(data)))

  ###
  ### GOAL : comparing q_t^s1 against q_t^s2 for pruning s1 with dust method
  ### loading the type specific functions
  A <- A(type = type)
  B <- B(type = type)

  #########
  ###
  ### INITIALIZATION
  ###
  ### costQ used with the shift operator
  ###
  cp <- rep(0, n) #cp vector cp[k] = index of the last change-point for data y(1) to y(k)
  costQ <- rep(0, n + 1) # costQ[k] optimal cost for data y(1) to y(k-1)
  nb <- rep(0, n) # number of element to consider at each iteration
  costQ[1] <- -penalty
  indexSet <- 0

  #########
  ###
  ### update rule Dynamic Programming
  ###
  for(t in 1:n) # at t, transform Q_{t-1} into Q_{t}
  {
    min_temp <- Inf
    for(i in indexSet)
    {
      ### weight (t-i) --- cost Si..t = S_i+1 to S_t --- costQ[i] = Q_(i) (Q_0 = -penalty) ###
      eval <- min_cost(A, B, S, shift(i), shift(t), costQ[shift(i)] + penalty)
      if(eval < min_temp){min_temp <- eval; index <- i}
    }
    costQ[shift(t)] <- min_temp
    cp[t] <- index

    ###########################
    ########################### Pruning step START
    ###########################

    if(length(indexSet) > 1)
    {
      PrunedIndexSet <- NULL ##### we keep the smallest index #####
      for(i in 1:length(indexSet))
      {
        s1 <- indexSet[i]

        if((pruningOpt == 2) || (pruningOpt == 3))  ### dust
        {
            if(i >= 2)  ### DUST
            {
                if(i == 2){s2 <- indexSet[1]}else{s2 <- sample(indexSet[1:(i-1)], 1)} # the index of the constraint (s2 < s1) and s1,s2 < t
                mu <- runif(1) * mu_max(S, shift(s1), shift(s2), shift(t), type)# the mu value to test
                val <- evalDual(mu, A, B, S, shift(s1), shift(s2), shift(t), costQ[shift(s1)] + penalty, costQ[shift(s2)] + penalty)
                if(val > costQ[shift(t)] + penalty){PrunedIndexSet <- c(PrunedIndexSet, s1)}
            }
        }

        if((pruningOpt == 1) || (pruningOpt == 3))  ### PELT additional pruning
        {
            val <- min_cost(A, B, S, shift(s1), shift(t), costQ[shift(s1)] + penalty)
            if(val > costQ[shift(t)] + penalty){PrunedIndexSet <- c(PrunedIndexSet, s1)}
        }

      }
      indexSet <- setdiff(indexSet, PrunedIndexSet)
    }

    ###########################
    ########################### Pruning step END
    ###########################

    nb[t] <- length(indexSet)

    indexSet <- c(indexSet, t) #add new test point
  }


  ########## backtracking changepoint ##########
  changepoints <- backtracking_changepoint(cp, n)
  ########## backtracking changepoint ##########

  return(list(changepoints = changepoints, nb = nb, lastIndexSet = indexSet, costQ = costQ[-1]))
}






