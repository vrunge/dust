
#' OP_R_1D
#'
#' @description OP algorithm for univariate time-series (with different possible data models)
#' @param data a vector of data to segment generated by \code{dataGenerator_1D}
#' @param penalty penalty value (non-negative)
#' @param type type of cost to use: \code{"gauss"}, \code{"exp"}, \code{"poisson"}, \code{"geom"}, \code{"bern"}, \code{"binom"}, \code{"negbin"}
#' @return a list with the change-point elements (each last index of each segment) and a vector \code{costQ} saving the optimal cost at each time step
#' @examples
#'  OP_R_1D(dataGenerator_1D(chpts = c(200,400), c(0,1), sdNoise = 1, type = "gauss"), log(400))
#'  OP_R_1D(dataGenerator_1D(chpts = c(50,100), c(1,7), type = "exp"), log(100))
#'  OP_R_1D(dataGenerator_1D(chpts = c(50,100), c(3,10), type = "poisson"), 10*log(100))
#'  OP_R_1D(dataGenerator_1D(chpts = c(50,100), c(0.7,0.3), type = "geom"), 5*log(100))
#'  OP_R_1D(dataGenerator_1D(chpts = c(50,100), c(0.7,0.2), type = "bern"), log(100)/2)
#'  OP_R_1D(dataGenerator_1D(chpts = c(50,100), c(0.7, 0.3), nbTrials = 5, type = "binom"), 5*log(100))
#'  OP_R_1D(dataGenerator_1D(chpts = c(50,100), c(0.4,0.7),
#'          nbSuccess = 10, type = "negbin"), 50*log(100))
OP_R_1D <- function(data,
                    penalty = 2*log(length(data)),
                    type = "gauss")
{
  ##########  ##########  ##########  ##########  ##########

  if(!is.vector(data)){stop('data is not a vector')}
  if(length(data) <= 1){stop('no data to segment')}
  if(penalty < 0){stop('penalty must be non negative')}

  allowed.types <- c("gauss", "exp", "poisson", "geom", "bern", "binom", "negbin")
  if(!type %in% allowed.types){stop('type must be one of: ', paste(allowed.types, collapse=", "))}

  ##########  ##########  ##########  ##########  ##########
  ###
  ### preprocessing
  ###
  ### S used with the shift operator
  ###
  n <- length(data)
  stat <- statistic(type = type)
  S <- c(0, cumsum(stat(data)))

  ###
  ### GOAL : comparing q_t^s1 against q_t^s2 for pruning s1 with dust method
  ### loading the type specific functions
  A <- A(type = type)
  B <- B(type = type)

  #########
  ###
  ### INITIALIZATION
  ###
  ### costQ used with the shift operator
  ###
  cp <- rep(0, n) #cp vector cp[k] = index of the last change-point for data y(1) to y(k)
  costQ <- rep(0, n + 1) # costQ[k] optimal cost for data y(1) to y(k-1)
  costQ[1] <- -penalty
  indexSet <- 0

  #########
  ###
  ### update rule Dynamic Programming
  ###
  for(t in 1:n) # at t, transform Q_{t-1} into Q_{t}
  {
    min_temp <- Inf
    for(i in indexSet)
    {
      ### weight (t-i) --- cost Si..t = S_i+1 to S_t --- costQ[i] = Q_(i) (Q_0 = -penalty) ###
      eval <- min_cost(A, B, S, shift(i), shift(t), costQ[shift(i)] + penalty)
      if(eval < min_temp){min_temp <- eval; index <- i}
    }
    costQ[shift(t)] <- min_temp
    cp[t] <- index
    indexSet <- c(indexSet, t) #add new test point
  }

  ########## backtracking changepoint ##########
  changepoints <- backtracking_changepoint(cp, n)
  ########## backtracking changepoint ##########

  return(list(changepoints = changepoints, costQ = costQ[-1]))
}


####################################################################################################
####################################################################################################
####################################################################################################


#' OP_R_MultiD
#'
#' @description OP algorithm for multivariate time-series (with different possible data models)
#' @param data a matrix of data to segment generated by \code{dataGenerator_MultiD}
#' @param penalty penalty value (non-negative)
#' @param type type of cost to use: \code{"gauss"}, \code{"exp"}, \code{"poisson"}, \code{"geom"}, \code{"bern"}, \code{"binom"}, \code{"negbin"}
#' @return a list with the change-point elements (each last index of each segment) and a vector \code{costQ} saving the optimal cost at each time step
#' @examples
#' data <- dataGenerator_MultiD(chpts = c(100,200),
#'                              parameters = data.frame(ts1 = c(0,-2), ts2 = c(0,1)))
#' OP_R_MultiD(data)$changepoints
#'
#' data <- dataGenerator_MultiD(chpts = c(50,100,150),
#'    parameters = data.frame(ts1 = c(0.4,0.3,0.5), ts2 = c(0.5,0.6,0.5), ts3 = c(0.3,0.4,0.6)),
#'    nbTrials = c(30,10,100), type = "binom")
#' OP_R_MultiD(data, 50*log(150))$changepoints
OP_R_MultiD <- function(data,
                        penalty = 2*nrow(data)*log(ncol(data)), ### != 1D ###
                        type = "gauss")
{
  ##########  ##########  ##########  ##########  ##########

  if(!is.matrix(data)){stop('data is not a matrix')} ### != 1D ###
  if(ncol(data) <= 1){stop('no data to segment')}
  if(penalty < 0){stop('penalty must be non negative')}

  allowed.types <- c("gauss", "exp", "poisson", "geom", "bern", "binom", "negbin")
  if(!type %in% allowed.types){stop('type must be one of: ', paste(allowed.types, collapse=", "))}

  ##########  ##########  ##########  ##########  ##########
  ##########  ##########  ##########  ##########  ##########
  ###
  ### preprocessing
  ###
  ### S used with the shift operator
  ###
  n <- ncol(data)
  p <- nrow(data) ### != 1D ###
  stat <- statistic(type = type)
  S <- cbind(0, t(apply(data, 1, function(x) cumsum(stat(x))))) ### != 1D ###

  # loading the type specific functions
  A <- A(type = type)
  B <- B(type = type)

  #########
  ###
  ### INITIALIZATION
  ###
  ### costQ used with the shift operator
  ###
  cp <- rep(0, n) #cp vector cp[k] = index of the last change-point for data y(1) to y(k)
  costQ <- rep(0, n + 1) # costQ[k] optimal cost for data y(1) to y(k-1)
  costQ[1] <- -penalty
  indexSet <- 0

  #########
  ###
  ### update rule Dynamic Programming
  ###
  for(t in 1:n) # at t, transform Q_{t-1} into Q_{t}
  {
    min_temp <- Inf
    for(i in indexSet)
    {
      ### weight (t-i) --- cost Si..t = S_i+1 to S_t --- costQ[i] = Q_(i) (Q_0 = -penalty) ###
      ### != 1D ###
      ### != 1D ###
      eval <- 0
      for(j in 1:p){eval <- eval + min_cost(A, B, S[j,], shift(i), shift(t), 0)}
      eval <- eval + costQ[shift(i)] + penalty
      ### != 1D ###
      ### != 1D ###

      if(eval < min_temp){min_temp <- eval; index <- i}
    }
    costQ[shift(t)] <- min_temp
    cp[t] <- index
    indexSet <- c(indexSet, t) #add new test point
  }

  ########## backtracking changepoint ##########
  changepoints <- backtracking_changepoint(cp, n)
  ########## backtracking changepoint ##########

  return(list(changepoints = changepoints, costQ = costQ[-1]))
}


####################################################################################################

#' OP_R_2param
#'
#' @description OP algorithm for bi-parametric time-series (with different possible links)
#' @param data a vector of data (type \code{"meanVar"}) generated by \code{dataGenerator_MV} or a data frame of data of dimension n x 2 (type \code{"regression"}) generated by \code{dataGenerator_Reg} with column named \code{x} and \code{y}.
#' @param penalty penalty value (non-negative)
#' @param type type of cost to use: \code{"meanVar"}, \code{"regression"}
#' @return a list with the change-point elements (each last index of each segment) and a vector \code{costQ} saving the optimal cost at each time step
#' @examples
#'
#' data <- dataGenerator_MV(c(50,100), c(0,1), c(0.5,0.6))
#' OP_R_2param(data, 4*log(100), type = "meanVar")
#'
#' data <- dataGenerator_MV(c(100,300), c(0,0), c(1,2))
#' OP_R_2param(data, 4*log(100), type = "meanVar")$changepoints
#'
#' data <- dataGenerator_MV(c(200,400,600), c(0,1,1), c(1,1,2))
#' OP_R_2param(data, 4*log(300), type = "meanVar")$changepoints
#'
#' data <- dataGenerator_Reg(chpts = c(50,100), A = c(1,-1), B = c(2,0))
#' OP_R_2param(data, 4*log(100), type = "regression")
#'
#' data <- dataGenerator_Reg(chpts = c(100,200), A = c(1,1), B = c(1,-1))
#' OP_R_2param(data, 4*log(100), type = "regression")$changepoints
OP_R_2param <- function(data,
                        penalty,
                        type = "meanVar")
{
  allowed.types <- c("meanVar", "regression")
  if(!type %in% allowed.types){stop('type must be one of: ', paste(allowed.types, collapse=", "))}
  if(penalty < 0){stop('penalty must be non negative')}

  ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### #####
  if(type == "meanVar")
  {
    if(!is.vector(data)){stop('data is not a vector')}
    if(length(data) <= 1){stop('no data to segment')}
    ###
    ### preprocessing
    ###
    ### S used with the shift operator
    ###
    n <- length(data)
    S <- c(0, cumsum(data))
    S2 <- c(0, cumsum(data^2))
    #########
    ###
    ### INITIALIZATION
    ###
    ### costQ used with the shift operator
    ###
    cp <- rep(0, n) #cp vector cp[k] = index of the last change-point for data y(1) to y(k)
    costQ <- rep(0, n + 1) # costQ[k] optimal cost for data y(1) to y(k-1)
    costQ[1] <- -penalty
    indexSet <- 0
    #########
    ###
    ### update rule Dynamic Programming
    ###
    for(t in 1:n) # at t, transform Q_{t-1} into Q_{t}
    {
      min_temp <- Inf
      index <- 0 #if all eval = Inf (start of a segment)
      for(i in indexSet)
      {
        ### weight (t-i) --- cost Si..t = S_i+1 to S_t --- costQ[i] = Q_(i) (Q_0 = -penalty) ###
        eval <- min_cost_meanVar(S, S2, shift(i), shift(t), costQ[shift(i)] + penalty)
        if(eval < min_temp){min_temp <- eval; index <- i}
      }
      costQ[shift(t)] <- min_temp
      cp[t] <- index
      indexSet <- c(indexSet, t) #add new test point
    }


  }
  ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### #####
  if(type == "regression")
  {
    if(!is.data.frame(data)){stop('data is not a data frame')}
    if(nrow(data) <= 1){stop('no data to segment')}
    if(ncol(data) != 2){stop('You must have only 2 columns: x and y')}
    if(all(colnames(data) != c("x","y"))){'colum names are not x and y'}
    ###
    ### preprocessing
    ###
    ### A,B,C,D,E,f used with the shift operator
    ###
    n <- nrow(data)
    A <- c(0, cumsum(data$x^2))
    B <- c(0, cumsum(data$x))
    C <- 0:n
    D <- -c(0, cumsum(data$x * data$y))
    E <- -c(0, cumsum(data$y))
    f <- c(0, cumsum(data$y^2))

    #########
    ###
    ### INITIALIZATION
    ###
    ### costQ used with the shift operator
    ###
    cp <- rep(0, n) #cp vector cp[k] = index of the last change-point for data y(1) to y(k)
    costQ <- rep(0, n + 1) # costQ[k] optimal cost for data y(1) to y(k-1)
    costQ[1] <- -penalty
    indexSet <- 0
    #########
    ###
    ### update rule Dynamic Programming
    ###
    for(t in 1:n) # at t, transform Q_{t-1} into Q_{t}
    {
      min_temp <- Inf
      index <- 0 #if all eval = Inf (start of a segment)
      for(i in indexSet)
      {
        ### weight (t-i) --- cost Si..t = S_i+1 to S_t --- costQ[i] = Q_(i) (Q_0 = -penalty) ###
        eval <- min_cost_regression(A,B,C,D,E,f, shift(i), shift(t), costQ[shift(i)] + penalty)
        if(eval < min_temp){min_temp <- eval; index <- i}
      }
      costQ[shift(t)] <- min_temp
      cp[t] <- index
      indexSet <- c(indexSet, t) #add new test point
    }
  }
  ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### #####
  ########## backtracking changepoint ##########
  changepoints <- backtracking_changepoint(cp, n)
  ########## backtracking changepoint ##########

  return(list(changepoints = changepoints, costQ = costQ[-1]))
}

