
## ----------------------------------- ##
## --- /////////////////////////// --- ##
## --- // Importing C++ Modules // --- ##
## --- /////////////////////////// --- ##
## ----------------------------------- ##

Rcpp::loadModule("FLATOPMD", TRUE)
Rcpp::loadModule("DUSTMODULEMD", TRUE)

#' dust.partitioner.MD
#'
#' @description Generates a DUST partitioner
#'
#' @param model A character string specifying the model for the data. The default is \code{gauss}. Available models are:
#' \itemize{
#'   \item \code{"gauss"}: Assumes the data follows a Gaussian distribution with known variance
#'   \item \code{"poisson"}: Assumes the data follows a Poisson distribution, typically for count data.
#'   \item \code{"exp"}: Assumes the data follows an exponential distribution.
#'   \item \code{"geom"}: Assumes the data follows a geometric distribution.
#'   \item \code{"bern"}: Assumes the data follows a Bernoulli distribution, typically for binary data.
#'   \item \code{"binom"}: Assumes the data follows a Binomial distribution, for experiments with a fixed number of trials.
#'   \item \code{"negbin"}: Assumes the data follows a Negative Binomial distribution, for overdispersed count data.
#'   \item \code{"variance"}: Assumes the data follows a Gaussian distribution with unknown variance and null mean.
#' }
#' @param method A character string specifying the method used to handle indices and pruning tests in the algorithm. The default is \code{detIndex_Eval4}, which automatically selects the quickest method for the chosen model. Other available methods are:
#' \itemize{
#'   \item \code{"randIndex_Eval0"} to \code{"randIndex_Eval5"}: Random index-based methods with different dual maximization algorithm (0 through 5).
#'   \item \code{"detIndex_Eval0"} to \code{"detIndex_Eval5"}: Deterministic index-based methods  with different dual maximization algorithm (0 through 5).
#' }
#' Here are the current available algorithms (\code{Eval4} is often the most efficient one)
#' \itemize{
#'   \item \code{"Eval0"}: random evaluation of the dual (with uniform distribution)
#'   \item \code{"Eval1"}:
#'   \item \code{"Eval2"}:
#'   \item \code{"Eval3"}:
#'   \item \code{"Eval4"}:
#'   \item \code{"Eval5"}:
#'   \item \code{"Eval6"}:
#' }
#' @param nb_l number of left constraints
#' @param nb_r number of right constraints
#' @param nbLoops number of iterations in the algorithm for maximizing the dual function
#'
#' @return a DUST partitioner object that provides methods:
#' \itemize{
#'   \item \code{prepare}, for preparing the algorithm;
#'   \item \code{compute}, once fit has been called, for computing the optimal partition of the data;
#'   \item \code{get_partition}, for retrieving the optimal partition once it has been computed; and
#'   \item \code{quick}, a wrapper for the 3 methods.
#' }
#' @examples
#' dust.partitioner.MD()
dust.partitioner.MD <- function(
    model = "gauss"
    , method = "detIndex_Eval4"
    , nb_l = NULL
    , nb_r = NULL
    , nbLoops = 10
)
{
  partitioner <- new(DUST_MD, model, method, nbLoops)

  assign(
    "append",
    function(data, penalty = NULL, nb_l = NULL, nb_r = NULL)
      partitioner$append_c(data, penalty, nb_l, nb_r),
    envir = partitioner
  )
  return(partitioner)
}
