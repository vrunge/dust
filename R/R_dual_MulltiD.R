
#' dust_R_multiD
#'
#' @description DUST algorithm for multivariate time-series (with different possible data models)
#' @param data a matrix of data to segment generated by \code{dataGenerator_MD}
#' @param penalty penalty value (non-negative)
#' @param type type of cost to use: \code{"gauss"}, \code{"exp"}, \code{"poisson"}, \code{"geom"}, \code{"bern"}, \code{"binom"}, \code{"negbin"}
#' @param pruningOpt the pruning option to use. 0 = nothing, 1 = PELT, 2 = dust, 3 = PELT + dust
#' @return a list with (1) the change-point elements (each last index of each segment in \code{changepoints}), (2) a vector `\code{nb} saving the number of non-pruned elements at each iteration, (3) a vector \code{lastIndexSet} containing the non-pruned indices at the end of the algo and (4) a vector \code{costQ} saving the optimal cost at each time step.
#' @examples
#' data <- dataGenerator_MD(chpts = c(100,200),
#'                          parameters = data.frame(ts1 = c(0,-2), ts2 = c(0,1)))
#' dust_R_MultiD(data)$changepoints
dust_R_MultiD <- function(data,
                          penalty = 2*nrow(data)*log(ncol(data)), ### != 1D ###
                          type = "gauss",
                          pruningOpt = 3)
{
  ## pruningOpt == 0: nothing
  ## pruningOpt == 1: PELT
  ## pruningOpt == 2: dust
  ## pruningOpt == 3: dust + PELT

  ##########  ##########  ##########  ##########  ##########

  if(!is.matrix(data)){stop('data is not a matrix')}
  if(length(data) <= 1){stop('no data to segment')}
  if(penalty < 0){stop('penalty must be non negative')}

  allowed.types <- c("gauss", "exp", "poisson", "geom", "bern", "binom", "negbin")
  if(!type %in% allowed.types){stop('type must be one of: ', paste(allowed.types, collapse=", "))}

  ##########  ##########  ##########  ##########  ##########
  ##########  ##########  ##########  ##########  ##########
  ###
  ### preprocessing
  ###
  ### S used with the shift operator
  ###
  n <- ncol(data)
  p <- nrow(data) ### != 1D ###
  stat <- statistic(type = type)
  S <- cbind(0, t(apply(data, 1, function(x) cumsum(stat(x))))) ### != 1D ###


  ###
  ### GOAL : comparing q_t^s1 against q_t^s2 for pruning s1 with dust method
  ### loading the type specific functions
  A <- A(type = type)
  B <- B(type = type)

  #########
  ###
  ### INITIALIZATION
  ###
  ### costQ used with the shift operator
  ###
  cp <- rep(0, n) #cp vector cp[k] = index of the last change-point for data y(1) to y(k)
  costQ <- rep(0, n + 1) # costQ[k] optimal cost for data y(1) to y(k-1)
  nb <- rep(0, n) # number of element to consider at each iteration
  costQ[1] <- -penalty
  indexSet <- 0

  #########
  ###
  ### update rule Dynamic Programming
  ###
  for(t in 1:n) # at t, transform Q_{t-1} into Q_{t}
  {
    min_temp <- Inf
    for(i in indexSet)
    {
      ### weight (t-i) --- cost Si..t = S_i+1 to S_t --- costQ[i] = Q_(i) (Q_0 = -penalty) ###
      ### != 1D ###
      ### != 1D ###
      eval <- 0
      for(j in 1:p){eval <- eval + min_cost(A, B, S[j,], shift(i), shift(t), 0)}
      eval <- eval + costQ[shift(i)] + penalty
      ### != 1D ###
      ### != 1D ###
      if(eval < min_temp){min_temp <- eval; index <- i}
    }
    costQ[shift(t)] <- min_temp
    cp[t] <- index

    ###########################
    ########################### Pruning step START
    ###########################

    if(length(indexSet) > 1)
    {
      PrunedIndexSet <- NULL ##### we keep the smallest index #####
      for(i in 1:length(indexSet))
      {
        s1 <- indexSet[i]

        if((pruningOpt == 2) || (pruningOpt == 3))  ### dust
        {
          if(i >= 2)  ### DUST
          {
            if(i == 2){s2 <- indexSet[1]}else{s2 <- sample(indexSet[1:(i-1)], 1)} # the index of the constraint (s2 < s1) and s1,s2 < t
            ### != 1D ###
            ### != 1D ###
            MAX <- 1
            for(j in 1:p){eval <- MAX <- min(MAX, mu_max(S[j,], shift(s1), shift(s2), shift(t), type))}
            mu <- runif(1) * MAX# the mu value to test
            val <- evalDual(mu, A, B, S[1,], shift(s1), shift(s2), shift(t), costQ[shift(s1)] + penalty, costQ[shift(s2)] + penalty)
            for(j in 1:p){val <- val + evalDual(mu, A, B, S[1,], shift(s1), shift(s2), shift(t), 0, 0)}
            ### != 1D ###
            ### != 1D ###
            if(val > costQ[shift(t)] + penalty){PrunedIndexSet <- c(PrunedIndexSet, s1)}
          }
        }

        if((pruningOpt == 1) || (pruningOpt == 3))  ### PELT additional pruning
        {
          ### != 1D ###
          ### != 1D ###
          val <- 0
          for(j in 1:p){val <- val + min_cost(A, B, S[j,], shift(s1), shift(t), 0)}
          val <- val + costQ[shift(s1)] + penalty
          ### != 1D ###
          ### != 1D ###
          if(val > costQ[shift(t)] + penalty){PrunedIndexSet <- c(PrunedIndexSet, s1)}
        }

      }
      indexSet <- setdiff(indexSet, PrunedIndexSet)
    }

    ###########################
    ########################### Pruning step END
    ###########################

    nb[t] <- length(indexSet)

    indexSet <- c(indexSet, t) #add new test point
  }

  ########## backtracking changepoint ##########
  changepoints <- backtracking_changepoint(cp, n)
  ########## backtracking changepoint ##########

  return(list(changepoints = changepoints, nb = nb, lastIndexSet = indexSet, costQ = costQ[-1]))
}

