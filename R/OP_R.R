
#' OP_R_1D
#'
#' @description OP algorithm for univariate time-series (with different possible data models)
#' @param data a vector of data to segment generated by \code{dataGenerator_1D}
#' @param penalty penalty value (non-negative)
#' @param type type of cost to use: \code{"gauss"}, \code{"exp"}, \code{"poisson"}, \code{"geom"}, \code{"bern"}, \code{"binom"}, \code{"negbin"}
#' @return a list with the change-point elements (each last index of each segment) and a vector \code{costQ} saving the optimal cost at each time step
#' @examples
#'  OP_R_1D(dataGenerator_1D(chpts = c(200,400), c(0,1), sdNoise = 1, type = "gauss"), log(400))
#'  OP_R_1D(dataGenerator_1D(chpts = c(50,100), c(1,7), type = "exp"), log(100))
#'  OP_R_1D(dataGenerator_1D(chpts = c(50,100), c(3,10), type = "poisson"), 10*log(100))
#'  OP_R_1D(dataGenerator_1D(chpts = c(50,100), c(0.7,0.3), type = "geom"), 5*log(100))
#'  OP_R_1D(dataGenerator_1D(chpts = c(50,100), c(0.7,0.2), type = "bern"), log(100)/2)
#'  OP_R_1D(dataGenerator_1D(chpts = c(50,100), c(0.7, 0.3), nbTrials = 5, type = "binom"), 5*log(100))
#'  OP_R_1D(dataGenerator_1D(chpts = c(50,100), c(0.4,0.7),
#'          nbSuccess = 10, type = "negbin"), 50*log(100))
OP_R_1D <- function(data, penalty, type = "gauss")
{
  ##########  ##########  ##########  ##########  ##########

  if(!is.vector(data)){stop('data is not a vector')}
  if(length(data) <= 1){stop('no data to segment')}
  if(penalty < 0){stop('penalty must be non negative')}

  allowed.types <- c("gauss", "exp", "poisson", "geom", "bern", "binom", "negbin")
  if(!type %in% allowed.types){stop('type must be one of: ', paste(allowed.types, collapse=", "))}

  ##########  ##########  ##########  ##########  ##########
  ###
  ### preprocessing
  ###
  ### S used with the shift operator
  ###
  n <- length(data)
  stat <- statistic(type = type)
  S <- c(0, cumsum(stat(data)))

  ###
  ### GOAL : comparing q_t^s1 against q_t^s2 for pruning s1 with dust method
  ### loading the type specific functions
  A <- A(type = type)
  B <- B(type = type)

  #########
  ###
  ### INITIALIZATION
  ###
  ### costQ used with the shift operator
  ###
  cp <- rep(0, n) #cp vector cp[k] = index of the last change-point for data y(1) to y(k)
  costQ <- rep(0, n + 1) # costQ[k] optimal cost for data y(1) to y(k-1)
  costQ[1] <- -penalty
  indexSet <- 0

  #########
  ###
  ### update rule Dynamic Programming
  ###
  for(t in 1:n) # at t, transform Q_{t-1} into Q_{t}
  {
    min_temp <- Inf
    for(i in indexSet)
    {
      ### weight (t-i) --- cost Si..t = S_i+1 to S_t --- costQ[i] = Q_(i) (Q_0 = -penalty) ###
      eval <- min_cost(A, B, S, shift(i), shift(t), costQ[shift(i)] + penalty)
      if(eval < min_temp){min_temp <- eval; index <- i}
    }
    costQ[shift(t)] <- min_temp
    cp[t] <- index
    indexSet <- c(indexSet, t) #add new test point
  }

  #########
  ###
  ### backtracking step
  ###
  changepoints <- n # vector of change-point to build
  current <- n

  while(changepoints[1] > 0)
  {
    pointval <- cp[current] #new last change
    changepoints <- c(pointval, changepoints) # update vector
    current <- pointval
  }
  return(list(changepoints = changepoints[-1], costQ = costQ[-1]))
}



####################################################################################################
####################################################################################################
####################################################################################################
## TO DO


#' OP_R_MultiD
#'
#' @description OP algorithm for univariate time-series (with different possible data models)
#' @param data a matrix of data to segment generated by \code{dataGenerator_MultiD}
#' @param penalty penalty value (non-negative)
#' @param type type of cost to use: \code{"gauss"}, \code{"exp"}, \code{"poisson"}, \code{"geom"}, \code{"bern"}, \code{"binom"}, \code{"negbin"}
#' @return a list with the change-point elements (each last index of each segment) and a vector \code{costQ} saving the optimal cost at each time step
OP_R_MultiD <- function(data, penalty, type = "gauss")
{
  ##########  ##########  ##########  ##########  ##########

  if(!is.vector(data)){stop('data is not a vector')}
  if(length(data) <= 1){stop('no data to segment')}
  if(penalty < 0){stop('penalty must be non negative')}

  allowed.types <- c("gauss", "exp", "poisson", "geom", "bern", "binom", "negbin")
  if(!type %in% allowed.types){stop('type must be one of: ', paste(allowed.types, collapse=", "))}

  ##########  ##########  ##########  ##########  ##########

  ### preprocessing
  n <- ncol(data)
  stat <- statistic(type = type)
  S <- cbind(0, t(apply(data, 1, function(x) cumsum(stat(x)))))

  # loading the type specific functions
  A <- A(type = type)
  B <- B(type = type)

  #########
  ###
  ### INITIALIZATION
  ###
  cp <- rep(0, n + 1) #cp vector cp[k] = index of the last change-point for data y(1) to y(k-1)
  costQ <- rep(0, n + 1) # costQ[k] optimal cost for data y(1) to y(k-1)
  costQ[1] <- -penalty

  indexSet <- NULL

  return(NULL)
}




####################################################################################################
####################################################################################################
####################################################################################################



#' OP_R_2Dquad
#'
#' @description OP algorithm for bivariate time-series (with different possible links)
#' @param data a vector of data (type \code{"meanVar"}) generated by \code{dataGenerator_MV} or a data frame of data of dimension n x 2 (type \code{"regression"}) generated by \code{dataGenerator_Reg}.
#' @param penalty penalty value (non-negative)
#' @param type type of cost to use: \code{"meanVar"}, \code{"regression"}
#' @return a list with the change-point elements (each last index of each segment) and a vector \code{costQ} saving the optimal cost at each time step
#' @examples
#'  OP_R_2Dquad(dataGenerator_MV(c(50,100), c(0,1), c(0.5,0.6)), 4*log(100))
#'  OP_R_2Dquad(dataGenerator_Reg(c(40,90), c(2,-1),  c(-1,2), c(1,2)), log(100))
OP_R_2Dquad <- function(data, penalty, type = "meanVar")
{


  return(NULL)
}

