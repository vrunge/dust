# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title MyModule: Exposing DUST_1D to R
#'
#' @name DUST_1D
#'
#' @description
#' This module exposes the \code{DUST_1D} C++ class to R, allowing you to create
#' instances of \code{DUST_1D} and call its methods directly from R.
#'
#' @export
NULL

#' @title MyModule: Exposing DUST_MD to R
#'
#' @name DUST_MD
#'
#' @description
#' This module exposes the \code{DUST_MD} C++ class to R, allowing you to create
#' instances of \code{DUST_MD} and call its methods directly from R.
#'
#' @export
NULL

#' Optimal Partitioning in 1D with Flat Model
#'
#' Computes the optimal partitioning of one-dimensional data using a flat model with an optional penalty parameter.
#'
#' @param inData A numeric vector representing the input data for partitioning.
#' @param inPenalty An optional numeric penalty parameter to control the number of partitions. Defaults to \code{NULL}, indicating a default penalty is used.
#' @return A list containing the results of the optimal partitioning, including identified change points and other model details.
#' @examples
#' data <- rnorm(100)
#' result <- flat_OP_1D(data, inPenalty = 1.0)
flat_OP_1D <- function(inData, inPenalty = NULL) {
    .Call(`_dust_flat_OP_1D`, inData, inPenalty)
}

#' Optimal Partitioning in MD with Flat Model
#'
#' Computes the optimal partitioning of multi-dimensional data using a flat model with an optional penalty parameter.
#'
#' @param inData A numeric matrix representing the input data for partitioning.
#' @param inPenalty An optional numeric penalty parameter to control the number of partitions. Defaults to \code{NULL}, indicating a default penalty is used.
#' @return A list containing the results of the optimal partitioning, including identified change points and other model details.
flat_OP_MD <- function(inData, inPenalty = NULL) {
    .Call(`_dust_flat_OP_MD`, inData, inPenalty)
}

#' Calculate Standard Deviation or MAD of Differences in a Numeric Vector
#'
#' The `sdDiff` function calculates a measure of variability (standard deviation or MAD)
#' of a numeric vector.
#' It supports three methods: "HALL", "MAD", and "SD".
#'
#' @param y A numeric vector.
#' @param method A character string specifying the method to use.
#'   Options are: \code{"HALL"}, \code{"MAD"}, and \code{"SD"}.
#'   Default is \code{"HALL"}.
#'
#' @return A numeric value representing the calculated measure of variability
#'   according to the specified method.
#'   \itemize{
#'     \item \code{"HALL"}: Calculates the standard deviation using a specific weighted
#'           difference method (HALL method).
#'     \item \code{"MAD"}: Returns the MAD (Median Absolute Deviation) of the differences
#'           between consecutive elements.
#'     \item \code{"SD"}: Returns the standard deviation of the differences
#'           between consecutive elements.
#'   }
#'
#' @examples
#' y <- c(rnorm(500, mean = 1), rnorm(500,mean = 2))
#' sdDiff(y, "HALL")
#' sdDiff(y, "MAD")
#' sdDiff(y, "SD")
#'
#' @export
sdDiff <- function(y, method) {
    .Call(`_dust_sdDiff`, y, method)
}

#' Data Normalization Function
#'
#' @name data_normalization_1D
#'
#' @description
#' Normalizes the input time series data `y` according to the specified `type`.
#' The normalization process depends on the statistical model type, which can be one of the following:
#' "gauss" (Gaussian/normal distribution), "exp" (exponential distribution),
#' "poisson" (Poisson distribution), "geom" (geometric distribution),
#' "bern" (Bernoulli distribution), "binom" (binomial distribution),
#' "negbin" (negative binomial distribution), or "variance"
#'
#' @param y A numeric vector representing the time series to be normalized and then segmented.
#' @param type A string specifying the model type for normalization.
#' The available options are "gauss", "exp", "poisson", "geom", "bern", "binom", "negbin", "variance".
#' The default is "gauss".
#' @return A numeric vector that is the normalized version of the input time series `y`.
#' @examples
#' # Normalize a random time series using the Gaussian model
#' normalized_y <- data_normalization_1D(rnorm(100), type = "gauss")
#'
#' # Normalize using the Poisson model
#' normalized_y <- data_normalization_1D(rpois(100, lambda = 3), type = "poisson")
#'
#' # Normalize using the Exponential model
#' normalized_y <- data_normalization_1D(rexp(100), type = "exp")
#'
#' @export
data_normalization_1D <- function(y, type = "gauss") {
    .Call(`_dust_data_normalization_1D`, y, type)
}

#' Data Normalization Function
#'
#' @name data_normalization_MD
#'
#' @description
#' Normalizes the input time series data `y` according to the specified `type`.
#' The normalization process depends on the statistical model type, which can be one of the following:
#' "gauss" (Gaussian/normal distribution), "exp" (exponential distribution),
#' "poisson" (Poisson distribution), "geom" (geometric distribution),
#' "bern" (Bernoulli distribution), "binom" (binomial distribution),
#' "negbin" (negative binomial distribution), or "variance"
#'
#' @param y A numeric matrix representing the time series to be normalized and then segmented.
#' @param type A string specifying the model type for normalization.
#' The available options are "gauss", "exp", "poisson", "geom", "bern", "binom", "negbin", "variance".
#' The default is "gauss".
#' @return A numeric matrix that is the normalized version of the input time series `y`, normalized row by row.
#' @examples
#' # Normalize a random time series using the Gaussian model
#' normalized_y <- data_normalization_MD(matrix(rnorm(100), nrow = 2), type = "gauss")
#' @export
data_normalization_MD <- function(y, type = "gauss") {
    .Call(`_dust_data_normalization_MD`, y, type)
}

