
#' dual_1D
#'
#' @description Computing the value of the dual at relative position mu (mu btw 0 and 1 is then rescaled)
#'
#' @param mu value for the dual (mu btw 0 and 1 is then re-scaled)
#' @param data a vector of data to segment generated by \code{dataGenerator_1D}
#' @param s1 index for q_t^s1
#' @param s2 index for q_t^s2
#' @param t time step t
#' @param type type of cost to use: \code{"gauss"}, \code{"exp"}, \code{"poisson"}, \code{"geom"}, \code{"bern"}, \code{"binom"}, \code{"negbin"}
#' @param OP FALSE or TRUE, using the OP algorithm or not to get the costQ vector, otherwise all cost set to zero
#' @param penalty penalty value (non-negative)
#' @return Value on the dual function
#' @examples
#' data <- dataGenerator_1D(chpts = c(15,30), parameters = c(1,10), type = "gauss")
#' dual_1D(mu =  1:99/100, data = data, s1 = 4, s2 = 2, t = 10, type = "gauss")
dual_1D <- function(mu, data, s1, s2, t,
                    type = "gauss",
                    OP = FALSE,
                    penalty = 2*length(data))
{
  if(!is.vector(data)){stop('data is not a vector or a matrix')}
  if(length(data) <= 1){stop('no data to segment')}
  if(penalty < 0){stop('penalty must be non negative')}

  allowed.types <- c("gauss", "exp", "poisson", "geom", "bern", "binom", "negbin")
  if(!type %in% allowed.types){stop('type must be one of: ', paste(allowed.types, collapse=", "))}

  ##########  ##########  ##########  ##########  ##########

  ###
  ### preprocessing
  ###
  n <- length(data)
  stat <- statistic(type = type)
  S <- c(0, cumsum(stat(data)))

  ###
  ### GOAL : comparing q_t^s1 against q_t^s2 for pruning s1 with dust method
  ### loading the type specific functions
  A <- A(type = type)
  B <- B(type = type)

  ###
  ### mu-rescaling (to be between the right bounds, with respect to the type)
  ###
  mu <- mu * mu_max(S, s1, s2, t, type)  #mu was between 0 and 1

  if(OP == FALSE)
  {
    res <- evalDual(mu, A, B, S, s1, s2, t, 0, 0)
  }

  if(OP == TRUE)
  {
    OPres <- OP_R_1D(data, penalty = penalty, type = type)
    cost <- OPres$costQ
    res <- evalDual(mu, A, B, S, s1, s2, t, cost[s1] + penalty, cost[s2] + penalty)
  }

  return(res)
}
