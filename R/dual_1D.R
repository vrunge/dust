
#' dual_1D
#'
#' @description Computing the value of the dual at relative position mu (mu btw 0 and 1 is then rescaled)
#'
#' @param mu value for the dual (mu btw 0 and 1 is then re-scaled)
#' @param data a vector of data to segment generated by \code{dataGenerator_1D}
#' @param s1 index for q_t^s1
#' @param s2 index for q_t^s2
#' @param t time step t
#' @param type type of cost to use: \code{"gauss"}, \code{"exp"}, \code{"poisson"}, \code{"geom"}, \code{"bern"}, \code{"binom"}, \code{"negbin"}
#' @param OP FALSE or TRUE, using the OP algorithm (\code{dust_R_1D}) or not to get the \code{costQ} vector, otherwise all cost set to zero
#' @param penalty penalty value (non-negative)
#' @param pruningOpt pruning option for \code{dust_R_1D}. See \code{pruningOpt} parameter in function \code{dust_R_1D}.
#' @return Value on the dual function
#' @examples
#' data <- dataGenerator_1D(chpts = c(15,30), parameters = c(1,10), type = "gauss")
#' dual_1D(mu =  1:99/100, data = data, s1 = 4, s2 = 1, t = 10, type = "gauss", OP = TRUE)
#' dual_1D(mu =  1:99/100, data = data, s1 = 4, s2 = 1, t = 10, type = "gauss")
dual_1D <- function(mu, data, s1, s2, t,
                    type = "gauss",
                    OP = FALSE, penalty = 2*length(data), pruningOpt = 3)
{
  ##########  ##########  ##########  ##########  ##########

  if(!is.vector(data)){stop('data is not a vector or a matrix')}
  if(length(data) <= 1){stop('no data to segment')}
  if(penalty < 0){stop('penalty must be non negative')}

  if((s1%%1 != 0) || (s2%%1 != 0)  || (t%%1 != 0)){stop('s1 or s2 or t is not an integer')}
  if((s1 >= t) || (s2 >= t) || (s1 <= 0) || (s2 <= 0)){stop('s1 and s2 must be smaller than t and positive')}
  if(any(mu > 1 | mu < 0)){stop('one of the mu values is not between 0 and 1 (0 and 1 included)')}

  allowed.types <- c("gauss", "exp", "poisson", "geom", "bern", "binom", "negbin")
  if(!type %in% allowed.types){stop('type must be one of: ', paste(allowed.types, collapse=", "))}

  ##########  ##########  ##########  ##########  ##########
  ###
  ### preprocessing
  ###
  ### S used with the shift operator
  ###
  n <- length(data)
  stat <- statistic(type = type)
  S <- c(0, cumsum(stat(data)))

  ###
  ### GOAL : comparing q_t^s1 against q_t^s2 for pruning s1 with dust method
  ### loading the type specific functions
  A <- A(type = type)
  B <- B(type = type)

  ###
  ### mu-rescaling (to be between the right bounds, with respect to the type)
  ###
  MAX <- mu_max(S, shift(s1), shift(s2), shift(t), type)
  mu <- mu * MAX  #mu was between 0 and 1

  if(OP == FALSE)
  {
    cost <- rep(NA, n)
    lastIndexSet <- NA
    res <- evalDual(mu, A, B, S, shift(s1), shift(s2), shift(t), 0, 0)
  }

  if(OP == TRUE)
  {
    algo_res <- dust_R_1D(data, penalty = penalty, type = type, pruningOpt = pruningOpt)
    cost <- algo_res$costQ
    lastIndexSet <- algo_res$lastIndexSet
    res <- evalDual(mu, A, B, S,
                    shift(s1), shift(s2), shift(t),
                    cost[shift(s1)] + penalty, cost[shift(s2)] + penalty)
  }

  ###
  ### all the info returned to the user
  ###
  return(list(dualValues = res,
              costQ = cost,                     ### NA if no algo run
              lastIndexSet = lastIndexSet,      ### NA if no algo run
              pruningBound = cost[t] + penalty, ### NA if no algo run
              mu_max = MAX))
}
